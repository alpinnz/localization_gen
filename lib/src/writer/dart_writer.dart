import '../model/localization_item.dart';

/// Generates strongly-typed Dart code with nested structure support
class DartWriter {
  /// The name of the generated localization class
  final String className;

  /// Whether to generate a static of(BuildContext) method
  final bool useContext;

  /// Whether the of(BuildContext) method should return a nullable type
  final bool nullable;

  /// Creates a new DartWriter instance
  ///
  /// The [className] parameter specifies the name of the generated class.
  /// The [useContext] parameter controls whether to generate the static of() method.
  /// The [nullable] parameter controls the return type nullability of the of() method.
  ///
  /// Example:
  /// ```dart
  /// final writer = DartWriter(
  ///   className: 'AppLocalizations',
  ///   useContext: true,
  ///   nullable: false,
  /// );
  /// ```
  DartWriter({
    required this.className,
    this.useContext = true,
    this.nullable = false,
  });

  /// Generate complete Dart file content
  String generate(List<LocaleData> locales) {
    if (locales.isEmpty) throw Exception('No locales to generate');

    final baseLocale = locales.first;
    final buffer = StringBuffer();

    // Header & imports
    buffer.writeln("// GENERATED CODE - DO NOT MODIFY BY HAND");
    buffer.writeln("// Generated by localization_gen");
    buffer.writeln();
    buffer.writeln("import 'package:flutter/widgets.dart';");
    buffer.writeln();

    // Main class
    buffer.writeln("/// Strongly-typed localization class");
    buffer.writeln("class $className {");
    buffer.writeln("  $className(this.locale);");
    buffer.writeln();
    buffer.writeln("  final Locale locale;");
    buffer.writeln();

    // Static of() method
    if (useContext) {
      buffer.writeln("  /// Get the localization instance from context");
      buffer.writeln(
          "  static $className${nullable ? '?' : ''} of(BuildContext context) {");
      buffer.writeln(
          "    return Localizations.of<$className>(context, $className)${nullable ? '' : '!'};");
      buffer.writeln("  }");
      buffer.writeln();
    }

    // Supported locales
    buffer.writeln("  /// All supported locales");
    buffer.writeln("  static const supportedLocales = [");
    for (final locale in locales) {
      buffer.writeln("    Locale('${locale.locale}'),");
    }
    buffer.writeln("  ];");
    buffer.writeln();

    // Build nested structure
    final nestedStructure = _buildNestedStructure(baseLocale.items);

    // Generate nested class getters
    for (final entry in nestedStructure.entries) {
      final key = entry.key;
      final value = entry.value;

      if (value is Map) {
        // This is a namespace, create a getter for nested class
        final nestedClassName = '_${_toPascalCase(key)}';
        buffer.writeln("  /// Access $key translations");
        buffer.writeln(
            "  $nestedClassName get $key => $nestedClassName(locale);");
        buffer.writeln();
      }
    }

    // Generate methods for top-level keys
    for (final entry in baseLocale.items.entries) {
      final item = entry.value;
      if (!item.key.contains('.')) {
        buffer.writeln(_generateMethod(item, locales));
      }
    }

    buffer.writeln("}");
    buffer.writeln();

    // Generate nested classes
    buffer.write(
        _generateNestedClasses(nestedStructure, locales, baseLocale.items));

    // Generate delegate
    buffer.writeln(_generateDelegate(locales));

    return buffer.toString();
  }

  /// Build nested structure from flat keys
  /// Example: {"auth.login.title": "Login"} -> {"auth": {"login": {"title": "Login"}}}
  Map<String, dynamic> _buildNestedStructure(
      Map<String, LocalizationItem> items) {
    final result = <String, dynamic>{};

    for (final item in items.values) {
      final parts = item.key.split('.');
      if (parts.length == 1) continue; // Skip top-level keys

      var current = result;
      for (var i = 0; i < parts.length - 1; i++) {
        current.putIfAbsent(parts[i], () => <String, dynamic>{});
        current = current[parts[i]] as Map<String, dynamic>;
      }
      current[parts.last] = item;
    }

    return result;
  }

  /// Generate nested classes for namespaces
  String _generateNestedClasses(
    Map<String, dynamic> structure,
    List<LocaleData> locales,
    Map<String, LocalizationItem> allItems,
  ) {
    final buffer = StringBuffer();

    for (final entry in structure.entries) {
      final key = entry.key;
      final value = entry.value;

      if (value is Map) {
        final className = '_${_toPascalCase(key)}';
        buffer.writeln("/// Translations for $key namespace");
        buffer.writeln("class $className {");
        buffer.writeln("  $className(this.locale);");
        buffer.writeln();
        buffer.writeln("  final Locale locale;");
        buffer.writeln();

        // Generate nested class getters
        for (final nestedEntry in value.entries) {
          final nestedKey = nestedEntry.key;
          final nestedValue = nestedEntry.value;

          if (nestedValue is Map) {
            final nestedClassName =
                '_${_toPascalCase(key)}_${_toPascalCase(nestedKey)}';
            buffer.writeln("  /// Access $key.$nestedKey translations");
            buffer.writeln(
                "  $nestedClassName get $nestedKey => $nestedClassName(locale);");
            buffer.writeln();
          }
        }

        // Generate methods for leaf nodes in this namespace
        for (final nestedEntry in value.entries) {
          if (nestedEntry.value is LocalizationItem) {
            buffer.writeln(_generateMethod(
                nestedEntry.value as LocalizationItem, locales,
                isNested: true));
          }
        }

        buffer.writeln("}");
        buffer.writeln();

        // Recursively generate deeper nested classes
        final valueAsMap = Map<String, dynamic>.from(value);
        buffer.write(
            _generateDeeperNestedClasses(key, valueAsMap, locales, allItems));
      }
    }

    return buffer.toString();
  }

  /// Generate deeper nested classes (3+ levels)
  String _generateDeeperNestedClasses(
    String parentKey,
    Map<String, dynamic> structure,
    List<LocaleData> locales,
    Map<String, LocalizationItem> allItems,
  ) {
    final buffer = StringBuffer();

    for (final entry in structure.entries) {
      final key = entry.key;
      final value = entry.value;

      if (value is Map<String, dynamic>) {
        final className = '_${_toPascalCase(parentKey)}_${_toPascalCase(key)}';
        buffer.writeln("/// Translations for $parentKey.$key namespace");
        buffer.writeln("class $className {");
        buffer.writeln("  $className(this.locale);");
        buffer.writeln();
        buffer.writeln("  final Locale locale;");
        buffer.writeln();

        // Generate methods for leaf nodes
        for (final nestedEntry in value.entries) {
          final nestedValue = nestedEntry.value;

          if (nestedValue is LocalizationItem) {
            buffer
                .writeln(_generateMethod(nestedValue, locales, isNested: true));
          }
        }

        buffer.writeln("}");
        buffer.writeln();
      }
    }

    return buffer.toString();
  }

  /// Generate a single method for a localization key
  String _generateMethod(LocalizationItem item, List<LocaleData> locales,
      {bool isNested = false}) {
    final buffer = StringBuffer();

    // Get the simple key (last part after dots)
    final simpleKey = item.key.split('.').last;

    // Add description as doc comment
    if (item.description != null) {
      buffer.writeln("  /// ${item.description}");
    }

    // Generate method signature
    if (item.hasParameters) {
      // Method with parameters: welcomeUser({required String name})
      final params =
          item.parameters.map((p) => 'required String $p').join(', ');
      buffer.writeln("  String $simpleKey({$params}) {");
      buffer.writeln("    switch (locale.languageCode) {");

      // Generate switch cases for each locale
      for (final locale in locales) {
        final localeItem = locale.items[item.key];
        if (localeItem != null) {
          buffer.write("      case '${locale.locale}': return ");
          buffer.write(
              _interpolateString(localeItem.value, localeItem.parameters));
          buffer.writeln(";");
        }
      }

      // Default case
      buffer.write("      default: return ");
      buffer.write(_interpolateString(item.value, item.parameters));
      buffer.writeln(";");

      buffer.writeln("    }");
      buffer.writeln("  }");
    } else {
      // Simple getter: String get hello
      buffer.writeln("  String get $simpleKey {");
      buffer.writeln("    switch (locale.languageCode) {");

      for (final locale in locales) {
        final localeItem = locale.items[item.key];
        if (localeItem != null) {
          buffer.writeln(
              "      case '${locale.locale}': return '${_escape(localeItem.value)}';");
        }
      }

      buffer.writeln("      default: return '${_escape(item.value)}';");
      buffer.writeln("    }");
      buffer.writeln("  }");
    }

    buffer.writeln();
    return buffer.toString();
  }

  /// Convert string to PascalCase
  String _toPascalCase(String input) {
    return input.split('_').map((part) {
      if (part.isEmpty) return '';
      return part[0].toUpperCase() + part.substring(1);
    }).join();
  }

  /// Interpolate string with parameters: "Welcome {name}" -> "Welcome $name"
  String _interpolateString(String template, List<String> params) {
    var result = template;
    for (final param in params) {
      result = result.replaceAll('{$param}', '\$$param');
    }
    return "'${_escape(result)}'";
  }

  /// Escape single quotes in strings
  String _escape(String text) {
    return text.replaceAll("'", "\\'");
  }

  /// Generate LocalizationsDelegate
  String _generateDelegate(List<LocaleData> locales) {
    final buffer = StringBuffer();

    buffer.writeln("/// Localization delegate for $className");
    buffer.writeln(
        "class ${className}Delegate extends LocalizationsDelegate<$className> {");
    buffer.writeln("  const ${className}Delegate();");
    buffer.writeln();
    buffer.writeln("  @override");
    buffer.writeln("  bool isSupported(Locale locale) {");
    buffer.writeln("    return $className.supportedLocales");
    buffer.writeln("        .map((l) => l.languageCode)");
    buffer.writeln("        .contains(locale.languageCode);");
    buffer.writeln("  }");
    buffer.writeln();
    buffer.writeln("  @override");
    buffer.writeln("  Future<$className> load(Locale locale) async {");
    buffer.writeln("    return $className(locale);");
    buffer.writeln("  }");
    buffer.writeln();
    buffer.writeln("  @override");
    buffer.writeln("  bool shouldReload(${className}Delegate old) => false;");
    buffer.writeln("}");
    buffer.writeln();
    buffer.writeln("/// Extension for easy access");
    buffer.writeln("extension ${className}Extension on $className {");
    buffer.writeln("  static const delegate = ${className}Delegate();");
    buffer.writeln("}");

    return buffer.toString();
  }
}
